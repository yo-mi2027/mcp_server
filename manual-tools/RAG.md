# RAG 設計書（階層推論型 RAG）

## 目的とスコープ

本設計書は、`manual-tools`（FastAPI バックエンド + MCP ブリッジ）を土台として構築する、階層推論型 RAG（Hierarchical Reasoning RAG）の設計を定義する。

対象範囲は以下とする。

- どの階層で情報を扱い、どう検索・推論するか（階層構造の定義）
- 既存 API（`list_manuals` / `get_toc` / `list_sections` / `get_section` / `search_text` / `find_exceptions` / `resolve_reference`）の組み合わせ方
- 将来導入予定のベクトル検索や `indices_dir` の使い方を含む、RAG 全体の構造
- Claude から見た「質問 → ツール呼び出し → コンテキスト構築 → 回答生成」のフロー

HTTP/JSON の詳細な仕様（フィールド名・型等）は、別途定義される MCP サーバー仕様書（API 契約）を正とし、本設計書では必要なフィールド名のみ参照する。

本設計では、RAG の推論フローを以下の三段構えで扱う。

- 探索フェーズ
- 審査フェーズ
- 統合フェーズ

## 前提と利用する API 情報

### 2.1 前提

- マニュアルは `manuals/` 以下のサブフォルダ単位で管理される。
- 各マニュアルには `00_目次.json`（ToC）があり、`id` / `title` / `file` / `children` を持つ。
- 章本文は `.txt` / `.md` / `.json` ファイルとして存在し、ToC の `file` フィールドで紐づく。
- `manual-tools` の FastAPI バックエンドは、API 契約仕様に従って JSON を返す。
- MCP ブリッジ（`manual-tools-mcp`）は、Zod スキーマを通じて `structuredContent` を Claude に渡す。
- `manual-tools` / `manual-tools-mcp` は「構造化されたマニュアル参照 API」を提供する低レイヤの基盤であり、高度な RAG ロジック自体は Claude 側の振る舞い（プロンプト設計など）で実現する。

### 2.2 RAG が依存する主なフィールド

本設計で RAG が前提とする API レスポンスのフィールドは以下とする。

- `list_manuals`
  - 文字列配列としてマニュアル名一覧（例: `"給付金編"`）
- `get_toc`
  - `manual`: マニュアル名
  - `toc`: 配列
    - `id`: `section_id` 相当
    - `title`: 章タイトル
    - `file`: 章本文ファイル名
    - `children`: 階層構造（配列または `null`）
- `list_sections`
  - `manual`: マニュアル名
  - `sections`: `section_id` の配列
- `get_section`
  - `manual`: マニュアル名
  - `section_id`: 章 ID
  - `title`: 章タイトル
  - `text`: 章本文（改行統一済み）
  - 任意: `file` / `encoding` / `id`
- `search_text`
  - `results`: 配列
    - `section_id`: 章 ID
    - `snippet`: ヒット周辺テキスト
- `find_exceptions`
  - `results`: 配列
    - `section_id`: 章 ID
    - `text`: 例外・注意箇所の周辺テキスト
- `resolve_reference`
  - `target_section`: 推定された `section_id`（または `null`）
  - HTTP エンドポイントは実装済みだが、MCP ツールとしては未公開

## 階層推論型 RAG の基本思想

### 3.1 目的

階層推論型 RAG は、マニュアルの構造（目次・章・節など）を意識して、次の流れで推論する。

- まず「どのマニュアル・どの章が関係しそうか」を高レベルで洗い出す
- 次に、その章の本文を実際に読み、「今回の質問に本当に関係する章」を選別する
- さらに、選別された複数の章から条件・例外を抜き出し、章間の参照（「第3章参照」など）も辿って統合的に判断する

単純に全文検索してヒットしたテキストをそのまま貼るのではなく、以下を組み合わせて「ルール全体の文脈」を把握しやすくする。

- 構造（`manual` / `section_id` / `title` / `children`）
- 章レベルの意味（章タイトルや目次情報）
- 例外・注意事項の明示的な抽出
- 複数章・複数特約をまたぐ横断的な読み

### 3.2 主なユースケース

特に重視するのは、複数章・複数特約・別章に散在した例外を横断して読む必要がある質問である。

- 入院日数や通算に関するルールを、主契約 + 複数特約（退院特約・通院特約など）と合わせて判断したい場合
- 手術 + 術後通算 + 抜釘通算 + 特別条件を同時に考慮する必要がある場合
- がん保険と総合医療保険の関係や、三疾病特約との優先順位を整理したい場合

単一の用語定義だけを知りたい質問は、このフローの「退化ケース」として扱う（同じパイプライン上で結果的に関係章が 1 つだけになる場合がある、という位置づけ）。

## 階層構造の定義

### 4.1 階層レベルの定義

本設計では、マニュアルを以下の階層で扱う。

- レベル 0（マニュアルレベル）
  - 単位: `manual`
  - 識別子: `manual` 名（例: `"給付金編"`）
- レベル 1（章レベル）
  - 単位: `section`
  - 識別子: `section_id`（例: `"03-1"`）
  - メタデータ: `manual` / `section_id` / `title` / `file` / `children`
- レベル 2（チャンクレベル）
  - 単位: 段落または行を基にしたチャンク（RAG 用の最小単位）
  - 識別子: `chunk_id`（実装側で採番）
  - メタデータ: `manual` / `section_id` / `title` / `chunk_id` / `chunk_text` / 章内の位置情報
- レベル 3（トークンレベル）
  - 実装上は LLM（Claude）が内部で扱うレベルであり、RAG 設計では明示的なインデックスは持たない。

### 4.2 ToC による階層構造

- `get_toc` の `toc` 要素は、`id` / `title` / `file` / `children` を持つ。
- 現状 `children` は `null` または空配列が前提だが、将来は以下のような構造を許容する。

例（将来像のイメージ）

- `id`: `"03"`
- `title`: `"第3章 手術"`
- `file`: `"03_手術.txt"`
- `children`:
  - `id`: `"03-1"`（小節 ID など）
  - `title`: `"帝王切開"`
  - `anchor`: `"..."`（任意）

階層推論型 RAG では、この `children` を使って「章 → 節 → 項」といった多段階の検索・推論を行う余地を残す。

## インデックスとストレージ設計（概念）

### 5.1 `indices_dir` の役割

`config.yaml` の `paths.indices_dir` は、将来的な検索インデックスの保存先として利用する。

- 現状: 未使用（正規表現ベース検索のみ）
- 将来: 以下のようなインデックスを置くことを想定する。

### 5.2 想定するインデックスの種類

#### 章レベルインデックス（セクションベース）

- 単位: レベル 1 の章（`manual` / `section_id` / `title` / `text`）
- 用途:
  - 「どの章がこの質問と関連しそうか」を大まかに絞る
  - `search_text` の結果と組み合わせて、章候補のスコアリングに使う

#### チャンクレベルインデックス（段落・行単位）

- 単位: レベル 2 のチャンク（`chunk_text`）
- 用途:
  - 候補章内で「どの段落が質問に最も関係するか」を高精度に見つける
  - 最終的に Claude に渡すコンテキストの選定に使う

### 5.3 メタデータ構造

各インデックスエントリは、少なくとも以下のメタデータを持つ想定とする。

- `manual`
- `section_id`
- `title`
- `chunk_id`（チャンクレベルの場合）
- `position`（章内での順番）
- `text`（チャンク本体）

具体的なベクトル化モデル・ライブラリ等は本設計書では固定しないが、上記メタデータ構造により、インデックスから取得した結果を API レベルの情報（`manual` / `section_id` / `title`）と必ず紐づけられるようにする。

## 推論フローの全体像（探索 → 審査 → 統合）

### 6.0 共通ルールの読み込み

ユーザーの質問を処理する前に、MCP クライアント（Claude や Cursor）は次の順で最低限のガイドを読む。

1. `manual="運用仕様編"` `section_id="01"`（Location Mode specification）
2. `manual="運用仕様編"` `section_id="02"`（Full Answer Mode specification）
   - 共通のハンドシェイクと lost in the middle 対策はこの 2 章に含める。

案件固有のプロンプトは、必要に応じて Claude アプリ上で直接読み込ませるか、雑務用ディレクトリなどに個別ファイルとして置き、明示的に `get_section` する。このシンプルな Step0 の後に、探索・審査・統合フローへ進む。

### 6.1 質問の意図解釈とマニュアル選択

ユーザーの質問に対して、Claude（MCP クライアント）はまず次の情報を読み取る。

- どのマニュアルに関する質問か
- 特定の章・特約が明示されているか（例: 「第3章」「術後通算」など）
- 質問の主眼が何か
  - 概念・定義を知りたいのか
  - 支払可否（条件判定）なのか
  - 例外・非該当条件なのか
  - 複数特約の関係整理なのか

複数マニュアルがある前提では、次のように扱う。

- ユーザーが明示した `manual` 名があれば、それを優先する。
- 明示がなければ、現状は単一マニュアル（例: `"給付金編"`）のみを対象とする前提で動く。
- 将来、複数マニュアルを横断する必要が出た場合は、`list_manuals` / `get_toc` の結果と質問文の語彙を照合し、優先マニュアルを推定するロジックを別途検討する。

### 6.2 三段構えの基本フロー

本設計の RAG は、以下の三つのフェーズで常に考える。

#### (1) 探索フェーズ（候補章 S0 の収集）

- 目的:
  - 質問に関係しそうな章を「漏れなく」候補として列挙する。
  - この時点では、「本当に回答に使うかどうか」はまだ決めない。
- 手段（例）:
  - `list_manuals` / `get_toc` で構造を把握し、目次テキスト（タイトル等）から関連がありそうな章を拾う
  - `search_text` で全文検索を行い、ヒットした `section_id` を候補に入れる
  - 例外・非該当系の質問では `find_exceptions` を併用し、結果に含まれる `section_id` を候補に加える
  - 通算や特別条件など、特定のテーマでは恒常的に参照すべき章を安全ネットとして候補に追加する
- 出力:
  - 候補章の集合 S0（`manual` / `section_id` / `title` / `snippet` 等のメタ情報を伴う）

#### (2) 審査フェーズ（候補章の評価と S1 抽出）

- 目的:
  - 探索フェーズで集めた候補 S0 のうち、質問に対する答えの一部を実際に含んでいる章だけを選別して S1 とする。
- 手段（例）:
  - S0 に含まれる各 `section_id` について `get_section` を呼び、本文 `text` を取得する
  - Claude が本文を読み、関連性を評価する
- 出力パターン:
  - ロケーションモード: `manual` / `section_id` / `title` / 簡単な理由のみをユーザーに返す
  - 完全回答モード: S1 を後続の統合フェーズに渡す

#### (3) 統合フェーズ（S1 の精読・チャンク化・整理）

- 目的:
  - S1 に含まれる章から、定義・条件・例外・参照関係を「漏れなく」抽出し、複数章の内容を突き合わせて整合的な回答を生成する。
- 手段（例）:
  - 各章の `text` をチャンク（段落・行ブロック）に分割する
  - 質問との関連度や `search_text` の `snippet` 位置を参考に、重要そうなチャンクを優先して読む
  - 各チャンクから定義・条件・例外・参照表現を抽出する
  - 参照表現がある場合は `resolve_reference` を使って `section_id` を推定し、必要に応じて追加の `get_section` を行う
- 出力:
  - 人間可読な自然言語の回答
  - 必要に応じて根拠となった章（`manual` / `section_id` / `title`）を明示する

## 各ステップの詳細設計

### 7.1 質問の意図解釈

Claude 側（プロンプト設計）の責務であり、本設計書では概念レベルのみ定義する。

主な分類軸:

- 対象マニュアル
  - 「給付金編」「コンプライアンスマニュアル」などを明示するかどうか
- 対象章の存在
  - 「第3章」「手術の章」などが直接指定されているか
- 質問タイプ（参考軸）
  - 一般的な説明（概要を知りたい）
  - 条件判定（このケースは支払対象か）
  - 例外・非該当条件の確認
  - 複数章・複数特約の整合性確認（A と B が矛盾していないか）

質問タイプによって「ロケーションモードで止めるか」「完全回答まで進めるか」を変えることはあり得るが、RAG 自体の構造（三段構え）は常に同じとする。

### 7.2 マニュアルの決定

複数マニュアルがある場合の基本方針:

- ユーザーが明示した `manual` 名があれば、それを優先する。
- 明示がなければ、現状は単一マニュアル（例: `"給付金編"`）のみを対象とする前提で動く。
- 将来、複数マニュアルを横断する必要が出た場合は、`list_manuals` / `get_toc` を見た上で、質問文の語彙と各 `manual` のタイトルを照合し、優先マニュアルを推定するロジックを別途検討する。

### 7.3 探索フェーズ（候補章 S0 の収集）

#### 7.3.1 ToC ベースの探索

- `get_toc` で manual ごとの目次を取得する。
- 質問文から抽出したキーワード（例: 術後通算、31 日継続、特別条件、通院特約 など）を、`toc` の `title` や ToC 前文と照合し、「関連しそうな章」を候補として追加する。
- 通算・特別条件・約款解釈など、どの質問でも安全ネットとして参照した方がよい章があれば、ルールとして明示的に候補に含める。

#### 7.3.2 `search_text` の利用

- `manual_name` と `query` を渡して `search_text` を呼び、関連セクションの一覧を取得する。
- `mode` はデフォルトで `regex` を使用し、OCR ノイズや表記揺れが想定される場合は `loose` を選択する。
- 返ってきた `results[].section_id` を「探索フェーズの候補章」として扱い、ToC ベースの候補と統合する。

優先度付けの一例:

- `snippet` 内に質問のキーワードが複数回出ているものほどスコアを高くする
- 同じ `section_id` が複数回ヒットした場合は統合し、代表的な `snippet` だけを保持する

#### 7.3.3 `find_exceptions` の利用

- 例外条件や非該当ケースに関する質問（「支払われないケースを教えて」等）の場合、`search_text` だけではなく `find_exceptions` も併用する。
- `find_exceptions` の `results[].section_id` を「例外に関する候補章」として扱い、`search_text` および ToC ベース候補とマージする。
- 同じ `section_id` が `search_text` と `find_exceptions` の両方に現れた場合、その章の優先度を高く扱う。

#### 7.3.4 S0 の形成

- 7.3.1〜7.3.3 で得られた候補章を集合 S0 としてまとめる。
- この時点では「漏れを極力減らす」ことを優先し、多少ノイズが混ざっていてもよい。
- S0 の各要素は `manual` / `section_id` / `title` / `snippet` 程度の軽量なメタ情報を持てば十分であり、本文 `text` はまだ取得しない。

### 7.4 審査フェーズ（候補章の評価と S1 抽出）

#### 7.4.1 `get_section` による本文取得

- S0 に含まれる各 `section_id` について `get_section` を呼び出す。
- 返り値から `manual` / `section_id` / `title` / `text` を取得する。
- `text` は章の全文であり、ここで初めて実際の内容を読む。

#### 7.4.2 関連性評価と S1 の形成

- Claude は、各章の `text` と質問内容を突き合わせて、次の観点で評価する。
  - 今回の質問に対する答えの一部が、明示的に書かれているか
  - 単語レベルでの一致だけでなく、文脈として本当に関係しているか
  - 条件判定や通算日数の計算に影響を与えるルールが含まれているか
  - 例外・非該当条件の記述が含まれているか
- 関係ありと判定した章だけを S1 に残す。
- S1 の各要素について、簡潔なメモ（なぜ関係ありと判断したか）を内部的に持っておくとよい。

#### 7.4.3 ロケーションモードと完全回答モード

- ロケーションモードの場合:
  - 審査フェーズで処理を止め、S1 に含まれる章について以下のみをユーザーに返す。
    - `manual`
    - `section_id`
    - `title`
    - 簡単な理由（例: 「術後通算の定義と条件が書かれている」など）
- 完全回答モードの場合:
  - S1 をそのまま統合フェーズに渡し、各章の中身を深掘りして最終的な回答を生成する。

### 7.5 統合フェーズ（S1 の精読・チャンク化・整理）

#### 7.5.1 章本文取得とチャンク分割

- S1 に含まれる各章の `text` はすでに取得済みである前提とする。
- 章本文をチャンクに分割する方針（概念）は次の通り。
  - 基本は段落ベース（空行で区切る、または行数一定ごとに区切る）
  - 長すぎる段落は行単位で再分割する
  - チャンクごとに `chunk_id`（章内通し番号）、`position`（`start_line` / `end_line` 等）、`chunk_text` を記録する
- 現行モードでは、`search_text` の `snippet` 位置やキーワードの出現箇所を手がかりに「重要そうなチャンク」を優先的に取り出す。

#### 7.5.2 チャンクレベルの選定ロジック

現状（ベクトル検索なし）の方針:

- `search_text` の `snippet` と章本文の位置を突き合わせ、該当付近のチャンクを優先して選ぶ
- 章内に複数ヒットがある場合は、その周辺チャンクを複数選択する
- 通算や特別条件など、構造的に重要なセクションに属するチャンクは、多少離れていても優先度を上げる

将来（ベクトル検索導入後）の方針:

- 章内チャンクに対してベクトル検索を行い、質問と近いチャンク上位 N 個を選ぶ
- `search_text` のキーワードマッチとベクトル類似度を組み合わせた再ランキングを行う

選定されたチャンクは、Claude に渡すコンテキストの中核となる。

#### 7.5.3 参照追跡（`resolve_reference`）

- `get_section` で取得した章本文の各チャンクについて、次のような参照表現を正規表現で検出する。
  - 「第3章」「第4章-1」
  - 「第3章 手術を参照」
  - 「別表○○を参照」 など
- 検出した `ref_text` を `resolve_reference` に渡し、以下を元に `target_section`（`section_id`）を推定する。
  - `manual_name`（現在のマニュアル）
  - `ref_text`（検出された参照表現）
- `resolve_reference` から `target_section` が返ってきた場合、その `section_id` に対して追加で `get_section` を呼び出し、参照先章からもチャンクを抽出する。
- `resolve_reference` は HTTP エンドポイントとして実装済みだが、MCP ツールとしては未公開である。

#### 7.5.4 回答生成時のコンテキスト構築ポリシー

コンテキストに含めるのは以下の情報とする。

- `manual` / `section_id` / `title`（メタデータ）
- 選定されたチャンクのテキスト
- 必要に応じて ToC の情報（章タイトル一覧）

複数章にまたがる場合、章ごとにブロックを分ける。

例（概念イメージ）:

```
[給付金編 第3章-1 手術]
テキスト AAAAA…

[給付金編 第9章 抗がん剤治療特約]
テキスト BBBBB…
```

Claude は、この構造化されたコンテキストを元に、どの章のどの規定に基づいて回答しているかを明示しながら回答することが望ましい。

## 現行モードと将来モード

### 8.1 現行モード（全文検索ベース階層推論）

現時点では、ベクトル検索や `indices_dir` を用いたインデックスはまだ実装されていない想定とする。

このため、以下の構成で階層推論（三段構え）を行う。

- 探索フェーズ:
  - ToC と `search_text` / `find_exceptions` による候補章 S0 の収集
- 審査フェーズ:
  - `get_section` で本文を取得し、質問との関連性を読んで S1 に絞り込む
- 統合フェーズ:
  - S1 に対してチャンク分割し、`search_text` の `snippet` 周辺等から重要チャンクを選定
  - 参照追跡は `resolve_reference` を利用し、必要に応じて追加の `get_section` を行う

この状態でも「章レベルで絞る → 本文を実際に読んで審査する → 関係章から条件・例外を抽出して統合する」という意味で、階層推論的な動きは実現できる。

静的な章ごとの重要度（重み付け）は導入せず、毎回の質問と ToC / `search_text` / `find_exceptions` の結果から動的に関連度を推定する。

### 8.2 将来モード（ベクトル検索導入後の階層推論）

今後、`indices_dir` にベクトルインデックスを構築することで、以下の拡張を行う。

- 探索フェーズの強化:
  - 章レベルインデックスを用いて、質問と意味的に近い章を効率的に抽出
  - `search_text` の結果とベクトル類似度を組み合わせて、候補章 S0 をより妥当な集合にする
- 統合フェーズの強化:
  - チャンクレベルインデックスを用いて、S1 に含まれる章のチャンクから質問と最も関係する箇所を特定
  - ベクトル検索結果とルールベース（例: 通算・特別条件などの章は優先）を組み合わせた再ランキング

これにより、以下が行いやすくなる。

- 単純なキーワードマッチに頼らず、言い換え表現や表記揺れにも強い検索
- 複数章にまたがる論理的整合性の検証

## API 契約との関係と変更ポリシー

本 RAG 設計書は API 契約（MCP サーバー仕様書）に依存しており、以下のフィールドを前提とする。

- `manual` / `section_id` / `title` / `text` / `children`
- `results[].section_id` / `results[].snippet` / `results[].text`
- `target_section`

API 側でこれらのフィールドを変更・削除する場合は、以下を行う。

1. API 契約書を更新
2. 本設計書の「依存フィールド一覧」とフロー（三段構え）を見直す

逆に、RAG 側で新たなメタデータが必要になった場合は、以下を行う。

1. 本設計書に「必要なメタデータ」として追記
2. API 契約書に新フィールドを追加（FastAPI 実装と MCP Zod を合わせて変更）

## 実装ロードマップ（抽象）

### フェーズ 1: API 仕様の固定と FastAPI の整合

- API 契約書に従って FastAPI のレスポンス形式を修正
- `get_section` / `list_sections` の不整合解消（`manual` / `section_id` / `title` / `text` を返す）
- 既存の pytest 契約テストを API 契約に合わせて拡張

### フェーズ 2: 現行全文検索ベース階層推論（三段構え）の整備

- `search_text` / `find_exceptions` / `get_section` / `get_toc` を組み合わせた「探索 → 審査 → 統合」フローを、Claude 側のプロンプト設計として明文化
- チャンク分割戦略の暫定実装
- ロケーションモードと完全回答モードの運用パターンを整理

### フェーズ 3: `indices_dir` を用いたインデックス構築

- オフラインでマニュアルを走査し、章レベル・チャンクレベルインデックスを作成
- `config.yaml` の `indices_dir` を実際に利用し始める

### フェーズ 4: ベクトル検索統合と再ランキング

- ベクトル検索の結果を `search_text` の結果と統合
- 章レベル・チャンクレベルのスコアリングロジックを調整
- 探索フェーズおよび統合フェーズにベクトルインデックスを組み込む

### フェーズ 5: `resolve_reference` の MCP 公開と高度な階層推論

- `resolve_reference` を MCP ツールとして公開
- 参照追跡を本格的に使った階層推論フローを整備
- 「参照元章 + 参照先章」を一組として扱うコンテキスト構築ポリシーを具体化

## まとめ

本設計書では、`manual-tools` を土台とした階層推論型 RAG の枠組みを定義した。

- マニュアル → 章 → チャンクという階層構造を前提とする
- `search_text` / `find_exceptions` / `get_section` / `get_toc` / `resolve_reference` などの API を、
  - 探索フェーズ（候補章 S0 の収集）
  - 審査フェーズ（本文を読んで S1 に絞り込む）
  - 統合フェーズ（S1 から条件・例外・参照を抽出して整理・統合する）
  の三段構えで組み合わせる

この方針は、将来ベクトル検索を導入しても変えずに維持する。つまり「階層推論型 RAG」であり、「探索 → 審査 → 統合」という考え方を守ること自体が本プロジェクトの中核的な設計方針である。

API の追加・変更やインデックス手法の変更があっても、以下を前提とする。

1. まず API 契約仕様を更新する
2. 次に本設計書のフロー（三段構え）との整合性を確認する
