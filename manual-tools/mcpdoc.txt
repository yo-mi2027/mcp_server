MCPサーバー仕様書（API 契約）

前提

・入力データは、章単位に分割されたテキストファイル（拡張子 .txt）を用いる。
・各マニュアルは manuals/ 以下の 1 サブフォルダに対応する。
　例：マニュアル名「給付金編」 → manuals/給付金編/

・目次は、同一フォルダ内の 00_目次.json を「正」とする。
　旧来の 00_目次.txt が存在していてもよいが、サーバー側では参照しない。

・バックエンドサーバーは Python 製の FastAPI アプリケーションとし、ローカルの HTTP API を提供する。
・クライアントは Claude Desktop を想定し、MCP ローカルツール（manual-tools）を経由して、この FastAPI バックエンドの HTTP API を利用する。
　MCP ローカルツールは Node.js/TypeScript 製の MCP ブリッジサーバーであり、標準入出力（stdio）で Claude Desktop と通信しつつ、内部で FastAPI バックエンドに HTTP で接続する。

・FastAPI バックエンドはローカル PC 上でのみ動作し、常時稼働は必須ではない（必要時に起動すればよい）。
・FastAPI バックエンドの実装言語は Python 3 系（開発環境は 3.9、仕様としては 3.9〜3.11 程度を想定）。
・Web フレームワークは FastAPI を採用する。
・FastAPI バックエンドの HTTP サーバーは 127.0.0.1 上でリッスンし、外部には公開しない。
・HTTP API のベースパスは / とする（すべてのエンドポイントはルート直下に配置）。

・MCP ブリッジサーバーは Node.js と公式 MCP SDK（@modelcontextprotocol/sdk）を用いて実装し、ツール名 manual-tools として Claude Desktop から認識される。
・MCP ブリッジサーバーは環境変数 MANUAL_TOOLS_BASE_URL により FastAPI バックエンドの URL を参照する（未設定時は http://127.0.0.1:ポート番号 をデフォルトとする想定）。
・本仕様書および MCP ブリッジサーバー（manual-tools-mcp）の Zod outputSchema を、manual-tools の HTTP/JSON API 契約の唯一の正とする。FastAPI バックエンドの実装は、これと常に一致させる。

マニュアルデータの構造

2.1 マニュアル単位

・1 マニュアルは manuals/ 直下の 1 フォルダに対応する。
・フォルダ名がそのまま manual_name として扱われる（例：「給付金編」）。
・各マニュアルフォルダには少なくとも以下が存在する前提とする。
　・機械可読な目次ファイル: 00_目次.json
　・章本文のテキストファイル群: 複数の .txt ファイル

2.2 ToC JSON（00_目次.json）

・00_目次.json は、指定マニュアルの目次と「章 ID → ファイル名」の対応を定義する唯一の正規情報源とする。

・概念的な構造
　ルートフィールド:
　manual: マニュアル名（文字列）。フォルダ名と一致することが望ましい。
　toc: 目次の配列。各要素が「章」を表す。

・toc 配列の各要素は、最低限次のフィールドを持つ。
　id: 章の識別子。章番号を表す簡潔な文字列（例: "01"、"02-1" など）。API における section_id と一致する。
　title: 章タイトル（例: 第1章 はじめに、第2章-1 入院(…) など）。
　file: 章本文に対応する .txt ファイル名。実体は manuals/{manual_name}/{file} に存在する前提。
　children（任意）: 階層付き目次用のフィールド。小見出しの配列または null。現時点では章レベルのみのため、children は空配列または null が基本。将来の拡張に備えてフィールドだけ定義しておく。

・children（小見出し）の各要素は、ラベルやアンカー情報など任意の構造を許容する。
　サーバー側は現時点では「存在すれば配列（または null）である」ことのみを前提とし、中身の具体的な解釈は行わない。

2.3 section_id とファイルの対応

・section_id は ToC JSON の id に一致する。
・章本文ファイルは ToC JSON の file フィールドに従い、manuals/{manual_name}/{file} から読み込まれる。
・実ファイル名には日本語や記号を含んでいてよいが、ToC 側の file と実際のファイル名が一致している必要がある。
・section_id と file の対応は常に ToC JSON を参照して決定し、ファイル名から直接推測しない。

MCP サーバーの概要

・名称
　manual-tools

・構成
　manual-tools という MCP ツールは、次の 2 層構成で提供される。

　FastAPI バックエンド（Python）: マニュアル参照用の HTTP API を提供。
　MCP ブリッジサーバー（Node.js/TypeScript）: MCP プロトコルで Claude Desktop と通信し、内部で FastAPI バックエンドの HTTP API を呼び出す。

・目的
　Claude（MCP）から利用可能な、「構造理解可能なマニュアル参照 API」を提供すること。

・利用形態
　Claude Desktop（UI） → MCP ローカルツール manual-tools（Node ブリッジ） → FastAPI サーバー（ローカル HTTP バックエンド）

・FastAPI バックエンドの動作環境
　ローカル PC 上で FastAPI アプリケーションとして起動。プロセスは必要なときのみ起動すればよい（常時稼働不要）。

・データ層
　ローカルフォルダ manuals/ 以下の .txt ファイル群と、各フォルダの 00_目次.json。

・FastAPI バックエンドのベース URL
　/ （全エンドポイントはルート直下に配置）

・FastAPI バックエンドのバインド先
　http://127.0.0.1:{PORT}
　（外部からのアクセスは前提にしない）

・MCP ブリッジサーバー
　・Node.js で実装し、公式 MCP SDK を使用する。
　・標準入出力を通じて Claude Desktop と接続し、ツール呼び出しを HTTP リクエストに変換して FastAPI バックエンドに転送する。
　・各 MCP ツールは、FastAPI バックエンドのエンドポイントと 1:1 で対応する。
　　ツール名と対応する HTTP エンドポイントは以下の通り。
　　list_manuals → GET /list_manuals
　　get_toc → GET /get_toc
　　list_sections → GET /list_sections
　　get_section → GET /get_section
　　search_text → POST /search_text
　　find_exceptions → POST /find_exceptions

　・ツールの入力と出力の形式は Zod を用いて定義され、FastAPI バックエンドの JSON 形式と整合するように設計する。
　・FastAPI から返ってきた JSON は、structuredContent とテキスト（JSON 文字列）として Claude に返す。
　・出力形式が Zod スキーマと一致しない場合、MCP SDK によって Output validation error（エラーコード -32602）が発生する。このため、FastAPI 側のレスポンス形式と MCP ブリッジ側の outputSchema は常に同期しておく必要がある。

レイヤー構成と責務（FastAPI バックエンド）

4.1 core

・設定ロード
　・config.yaml および環境変数を読み込み、pydantic による型付き設定オブジェクトとして扱う。

・起動時バリデーション
　・マニュアル一覧の検出。
　・ToC JSON 構造の緩やかな検証。
　・ToC で参照されるファイルの存在確認（不足していても起動は継続し、ログで警告）。

・共通ユーティリティ
　・テキスト正規化（改行コードの統一、NFKC 正規化など）。
　・正規表現パターンの定義など。

4.2 repositories

・役割
　ファイルシステム I/O と ToC ベースの解決を担当する。

・主な責務
　・マニュアル一覧の列挙。
　・指定マニュアルの ToC JSON（00_目次.json）の読み込み。
　・セクション一覧（section_id のリスト）の取得。
　・manual_name と section_id から、ToC の file 情報を使って章本文を取得。
　・検索サービス向けに、全セクションを順番に返すイテレータを提供。

4.3 services

・役割
　ドメインロジック（検索・例外抽出・ToC 整形など）を担当する。

・主な責務
　・ToC の整形
　　フラット構造（単純な章一覧）。
　　階層構造（children を含む形）。現時点では children は空配列または null が基本だが、将来は小見出しを実際に格納できる。

　・検索ロジック
　　search_text エンドポイントの検索モード:
　　　plain: 文字列部分一致
　　　regex: 正規表現検索（不正パターンはプレーン一致にフォールバック）
　　　loose: 文字間の空白・記号を無視する「ゆるい一致」

　　検索結果からのスニペット生成（ヒット周辺の文脈抽出）。

　・例外抽出
　　find_exceptions エンドポイントで、例外・禁止・非該当・除外系の語彙に基づき候補箇所を抽出し、周辺文脈をまとめる。

　・将来予定の参照解決
　　「第○章を参照」などの記述から対応セクションを推定するロジック（resolve_reference）。

4.4 routers

・FastAPI のルーターレイヤー。
・HTTP エンドポイント定義（/list_manuals, /get_toc, /list_sections, /get_section, /search_text, /find_exceptions 等）。
・依存性注入（Depends）によりリポジトリやサービスを取得する。
・MCP 側のツール定義と 1:1 に対応するエンドポイント設計を意識する。

4.5 main

・アプリケーションファクトリ
　create_app に相当する関数で FastAPI インスタンスを生成。

・起動時イベント
　・設定のロード。
　・マニュアル一覧の検出と、ToC/ファイルの起動時バリデーション。

・ルーターのマウント
　routers モジュールをアプリケーションに登録。

・ヘルスチェック
　/healthz で簡易な生存確認 API を提供。

設定（config.yaml）の仕様

5.1 設定読み込みの優先度

・環境変数
・config.yaml
・コード内のデフォルト値

環境変数を優先しつつ、config.yaml がなくてもデフォルトで動作可能な構成とする。

5.2 主な設定項目

server
　host: バインドするホスト名（通常は 127.0.0.1）。
　port: リッスンポート番号。
　base_path: API のベースパス。現時点では / 固定運用。

paths
　manuals_dir: マニュアルフォルダのルートディレクトリ。
　indices_dir: 検索インデックス保存先（将来のベクトル検索導入を想定）。
　runtime_dir: ログや一時ファイルの保存に利用するルート（例: var）。

search
　engine: 検索エンジンの種別。現状は "regex"（正規表現ベース）を前提とする。
　max_results: /search_text のデフォルト最大件数（例: 10）。

cache
　section_ttl_seconds: 章本文キャッシュの有効期限（秒）。
　max_sections_in_memory: メモリ上にキャッシュする最大章数。
　file: 将来ディスクキャッシュに利用する場合のパス（現時点では未使用または null を許容）。

security
　allowed_roots: ファイルアクセスを許可するルートパスのリスト。
　allow_symlink: シンボリックリンクを辿るかどうか（デフォルトは false）。

toc
　source: 目次ソース。現状は "json_only" を前提とする。将来的に "prefer_json" や "txt_only" などに拡張可能。
　path_pattern: ToC JSON のパステンプレート（例: manuals/{manual}/00_目次.json）。

manuals_root
　マニュアルルートディレクトリ名。paths.manuals_dir と同義だが、既存設定との互換性のため保持。

起動時バリデーション（FastAPI バックエンド）

6.1 マニュアル検出

・manuals_dir 直下のサブディレクトリを列挙し、そのフォルダ名を manual_name として採用する。
・検出した manual_name のリストを、起動ログに INFO レベルで出力する。

6.2 ToC JSON 構造チェック

・各マニュアルについて 00_目次.json を読み込み、以下を緩やかに確認する。
　・ルートに manual（文字列）と toc（配列）が存在する。
　・toc の各要素が id（文字列）、title（文字列）、file（文字列）を持つ。
　・children フィールドが存在する場合は、配列または null である。

・不整合があれば、原則として起動は継続し、警告ログを残す（致命的エラーにはしない）。

6.3 ファイル存在チェック

・ToC JSON の各エントリについて、manuals_dir/manual_name/file の存在を確認する。
・存在しない場合、警告ログとして記録する（例: [validate] manual=給付金編 file missing: ...）。
・起動自体は継続し、該当章へのアクセス時に 404 を返す振る舞いとする。

この方針により、OCR 前処理が未完了（すべての章をまだ作成していない状態）でも、利用可能な章だけでサーバーを使用できる。

提供 API 一覧（HTTP レベル, FastAPI バックエンド）

関数名は MCP 側のツール名に相当する名前。HTTP メソッドとパスは FastAPI 側のエンドポイント。

7.1 list_manuals

HTTP: GET
パス: /list_manuals
クエリ引数: なし

戻り値:
マニュアル名の配列（例: ["給付金編", "コンプライアンスマニュアル"]）

概要:
登録済みマニュアル一覧を返す。
FastAPI バックエンドは文字列配列を返し、MCP ブリッジ側で structuredContent.manuals に包んでツール出力とする。

7.2 get_toc

HTTP: GET
パス: /get_toc

クエリ引数:
manual_name（必須）
hierarchical（任意, 真偽値。省略時は false と同等）

戻り値:
manual（マニュアル名）
toc（章の配列）

toc の各要素:
id: 章 ID（section_id と一致）
title: 章タイトル
file: 章本文ファイル名
children: 小見出し配列または null（hierarchical=true のときに含まれる想定。hierarchical=false の場合、children フィールドは省略してもよい）

概要:
指定マニュアルの 00_目次.json を読み取り、フラット版または将来拡張を見据えた階層版の目次構造を返す。
現状は hierarchical=true でも、children が空配列または null の章レベル構造となる。
MCP ブリッジ側の outputSchema と整合する JSON を返す。

7.3 list_sections

HTTP: GET
パス: /list_sections

クエリ引数:
manual_name（必須）

戻り値:
manual: マニュアル名
sections: section_id の配列

例:
{
"manual": "給付金編",
"sections": ["01", "02-1", "02-2", ...]
}

概要:
指定マニュアルのセクション ID 一覧（ToC の id の一覧）を返す。
FastAPI バックエンドはこのオブジェクト形式を返し、MCP ブリッジ側の Zod outputSchema と一致させる。

7.4 get_section

HTTP: GET
パス: /get_section

クエリ引数:
manual_name（必須）
section_id（必須）

戻り値（基本形）:
manual: マニュアル名（例: "給付金編"）
section_id: 章 ID（例: "03-1"）
title: 章タイトル（ToC の title に一致）
text: 章本文（改行統一済み）

任意で追加されるフィールド:
file: 章本文ファイル名（ToC の file）
encoding: テキストのエンコーディング（例: "utf-8"）
id: 章 ID（section_id と同値）

概要:
指定セクションの全文を返す。
章が存在しない場合やファイル欠落時には 404 を返す。
MCP ブリッジ側では manual, section_id, title, text を必須フィールドとして outputSchema に定義するため、FastAPI 側のレスポンスもこれらを必ず含める。

7.5 search_text

HTTP: POST
パス: /search_text

リクエストボディ:
manual_name（必須）
query（必須）
section_id（任意。指定時はその章のみ対象）
mode（任意。plain / regex / loose。省略時は regex をデフォルトとする実装を想定）
limit（任意。最大件数、デフォルトは設定値）

戻り値:
results（配列。各要素は section_id と snippet を含む）

各要素:
section_id: 章 ID
snippet: ヒット箇所周辺の抜粋テキスト

概要:
全文検索または正規表現検索を行い、ヒットした章とその周辺スニペットを返す。
mode により検索の挙動が変化する（詳細は 8 章）。
MCP ブリッジ側の outputSchema と整合する JSON を返す。

7.6 find_exceptions

HTTP: POST
パス: /find_exceptions

リクエストボディ:
manual_name（必須）
section_id（任意。指定時はその章のみ対象）
limit（任意）

戻り値:
results（配列。各要素は section_id と text を含む）

各要素:
section_id: 章 ID
text: 該当箇所と周辺文脈をまとめた文字列

概要:
「留意点」「禁止」「支払われない」などの例外・非該当・禁止事項に関する記述を抽出し、その周辺文脈を返す。
MCP ブリッジ側の outputSchema と整合する JSON を返す。

7.7 resolve_reference（予約）

HTTP: POST
パス: /resolve_reference

状態: 将来実装予定（現時点では MCP ツールとしては未公開）

想定リクエスト:
manual_name
ref_text（例: 「第3章 重大手技を参照」などの文言）

想定戻り値:
target_section（推定される section_id）

概要:
文中の「第○章」「第△節」などの参照表現から、対応する章 ID を推定する。
将来 MCP ツール化する際には、Zod スキーマと併せて本仕様書を更新する。

7.8 healthz

HTTP: GET
パス: /healthz

クエリ引数: なし

戻り値:
ok フィールドに true を持つようなシンプルな JSON

例:
{ "ok": true }

概要:
MCP 側が「サーバーが起動しているか」を確認するためのヘルスチェックエンドポイント。

検索モードの仕様（/search_text）

8.1 共通仕様

・テキストは検索前に NFKC 正規化され、改行コードも統一される。
・検索対象は、指定マニュアルの各セクション本文。
　section_id が指定されていれば、その章のみを対象。
　指定が無ければ、list_sections 相当の全章を対象に順次検索。
・結果は上位 limit 件まで返す（limit 未指定時は設定値またはデフォルトを使用）。

8.2 plain モード

・query をそのまま文字列として扱う部分一致モード。
・正規表現ではなく、「この文字列が含まれているか」を素朴に判定する。
・日本語中心の想定のため、大文字小文字の扱いによる影響はほぼ想定しない。

8.3 regex モード

・query を正規表現パターンとして解釈するモード。
・高度なパターン検索（文字間の任意の空白・記号を許容する等）が可能。
・パターンコンパイルに失敗した場合（不正な正規表現など）は、
　例外をそのまま外に出さず、plain モードと同等のプレーン部分一致にフォールバックする。
　この際も HTTP ステータスは 500 ではなく 200 とする（空結果も許容）。

8.4 loose モード

・OCR ノイズや空白混入に強い、「ゆるい一致」モード。

・内部的な挙動のイメージ:
　クエリ文字列の各文字の間に、空白（半角・全角）や中点、スラッシュ（全角・半角）、各種ハイフンなどを許容する正規表現を自動生成する。
　例として、「帝王切開」を指定した場合、
　「帝 王 切 開」や「帝・王/切-開」、「帝　王　切　開」などの表記揺れもマッチするようなパターンを使用する。

・これにより、テキスト中がばらばらな表記になっていても、ユーザーは単に「帝王切開」と指定するだけでヒットさせることができる。

8.5 スニペット生成

・最初にマッチした位置の前後一定範囲（目安として前後 80 文字程度）を抜き出し、前後が切れている場合には省略記号（…）を付与した文字列を snippet として返す。
・章内に複数マッチがある場合、原則として最初のマッチのみを利用する。

例外抽出の仕様（/find_exceptions）

・対象となるテキストは、/search_text と同様に正規化済みの章本文。
・行単位で走査し、あらかじめ定義した語彙にマッチする行を検出する。

代表的な語彙例:
　留意、注意、例外、対象外、禁止
　適用しない、支払われない、支給されない
　不支給、不適用、除外、取り扱わない など

・マッチした行について、その前後数行をまとめて 1 つの text として返す。

・返却要素の構造:
　section_id: 該当箇所を含む章の ID。
　text: マッチ行およびその周辺文脈をまとめた文字列。

ログ方針

・ログレベル
　通常運用時は INFO。開発・デバッグ時には DEBUG を使用。

・出力対象

　起動時:
　・検出されたマニュアル一覧。
　・各マニュアルの ToC バリデーション結果。

　リクエスト処理時:
　・エンドポイント名。
　・manual_name。
　・section_id（必要に応じて）。
　・result_count（検索系）。
　・処理時間（ミリ秒）。

・出力しないもの
　マニュアル本文の全文。
　個々の章の全文テキスト。

・エラー時
　内部で一意な error_id を発行し、詳細なスタックトレースと共にログに記録。
　クライアントには error_id を含む簡潔なレスポンスのみ返す。

エラーレスポンス仕様

11.1 400 Bad Request

・必須パラメータが欠如している場合。
・パラメータの形式が明らかに不正な場合。

レスポンス例のイメージ:
　error フィールドに "invalid_request"、message フィールドに簡潔な説明文を持つ JSON。

11.2 404 Not Found

・manual_name に対応するフォルダが存在しない場合。
・section_id に対応する章が ToC 上に存在しない、または ToC にはあるが実ファイルが存在しない場合。

レスポンスには、どのリソースが見つからなかったか（マニュアルまたは章）を含めたメッセージを返す。

11.3 422 Unprocessable Entity

・FastAPI/pydantic によるスキーマバリデーションエラー（例: mode が定義外の文字列など）。
　FastAPI 標準のバリデーションエラーレスポンスをそのまま利用する。

11.4 500 Internal Server Error

・想定外の例外が発生した場合。

レスポンス例のイメージ:
　error フィールドに "internal_error"、error_id フィールドに内部ログと対応づける ID を含む JSON。
　詳細はサーバーログにのみ記録する。

テスト方針（最小セット, FastAPI バックエンド）

・テストフレームワークとして pytest を採用する。
・FastAPI の TestClient（内部的に httpx を使用）でエンドポイントを直接呼び出す契約テストを行う。

12.1 実装済みおよび想定している契約テスト（概要）

/list_manuals
・少なくとも 1 つ以上のマニュアルが返ること。
・戻り値が文字列配列であること。

/get_toc
hierarchical パラメータなし（または false）の場合:
・manual フィールドが指定値と一致する。
・toc が配列であり、1 件以上の要素を持つ。
・各要素が最低限 id / title / file を持つ。

hierarchical=true の場合:
・上記に加え、children フィールドが存在する場合は配列または null であることを確認。

/list_sections
・manual フィールドが指定した manual_name と一致すること。
・sections が配列であり、要素がすべて文字列であること。

/get_section
・既存の section_id で 200 が返り、manual / section_id / title / text がすべて存在し、text に本文が含まれていること。
・存在しない section_id で 404 が返ること。

/search_text
・検索語が実在するケース（例: 帝王切開 を mode: loose で検索）で、結果が 1 件以上返ること。
・明らかに存在しない語に対して、結果が 0 件になること。
・不正な正規表現（例: 開き括弧のみなど）を mode: regex で投げても 500 にならず、200 で結果が返る（プレーン一致にフォールバックしている）こと。

/find_exceptions
・固定のサンプルデータに対して、少なくとも 1 件以上の例外候補が返ること。

運用イメージ（抽象）

13.1 サーバー側（FastAPI バックエンド）

・Python の仮想環境を有効化する。
・必要なライブラリ（FastAPI, pydantic, uvicorn, PyYAML, httpx, pytest 等）をインストールする。
・FastAPI アプリケーションを 127.0.0.1 の指定ポートで起動する。
・起動時に設定とマニュアルをロードし、ToC/ファイルのバリデーション結果をログに出力する。
・起動後、/healthz にアクセスして生存確認が可能。

13.2 MCP ブリッジサーバー側（Node.js）

・Node.js 環境で MCP ブリッジ用のプロジェクトを用意し、公式 MCP SDK と Zod 等をインストールする。
・MANUAL_TOOLS_BASE_URL などの環境変数を設定し、FastAPI バックエンドの URL を指定する。
・MCP ブリッジサーバーを標準入出力モードで起動し、Claude Desktop の MCP 設定に manual-tools として登録する。
・Claude Desktop からツールが呼び出されると、ブリッジサーバーが対応する HTTP エンドポイント（/list_manuals, /get_toc, /list_sections, /get_section, /search_text, /find_exceptions）を叩き、そのレスポンスを structuredContent とテキストとして返す。
・FastAPI 側の出力 JSON 形式と MCP ブリッジ側の Zod スキーマが一致していることを常に保つ。

13.3 クライアント側（Claude MCP を想定）

・セッション開始時に list_manuals と get_toc を呼び、利用可能なマニュアルと章構造を把握する。

・利用者からの質問に応じて:
　・get_section で該当章のルール本文を取得し、必要に応じて要約や解釈を行う。
　・search_text（必要に応じて mode: loose）で関連箇所を検索する。
　・find_exceptions で例外・注意点の候補を一括取得する。

・将来的には、文中の「第○章参照」などが出てきた際に resolve_reference を利用して参照先章を追跡し、複数章の整合性を確認したうえで回答生成に利用する。